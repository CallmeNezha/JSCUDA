// Generated by CoffeeScript 1.10.0
(function() {
  var JC, batchA, batchB, batchC, date, hostOut, i, matrixWatch, mbdA, mbdB, mbdC, num;

  JC = require("../linear");

  date = new Date();

  JC.cudaDeviceInit();

  batchA = (function() {
    var j, results;
    results = [];
    for (i = j = 0; j < 1; i = ++j) {
      results.push(new JC.MatrixD(2, 2, new Float32Array((function() {
        var k, results1;
        results1 = [];
        for (num = k = 0; k < 4; num = ++k) {
          results1.push(num);
        }
        return results1;
      })())));
    }
    return results;
  })();

  batchB = (function() {
    var j, results;
    results = [];
    for (i = j = 0; j < 1; i = ++j) {
      results.push(new JC.MatrixD(2, 2, new Float32Array((function() {
        var k, results1;
        results1 = [];
        for (num = k = 0; k < 4; num = ++k) {
          results1.push(num);
        }
        return results1;
      })())));
    }
    return results;
  })();

  batchC = (function() {
    var j, results;
    results = [];
    for (i = j = 0; j < 1; i = ++j) {
      results.push(new JC.MatrixD(2, 2, new Float32Array((function() {
        var k, results1;
        results1 = [];
        for (num = k = 0; k < 4; num = ++k) {
          results1.push(num);
        }
        return results1;
      })())));
    }
    return results;
  })();

  matrixWatch = batchC[0];

  hostOut = new Float32Array(4);

  matrixWatch.copyTo(4, hostOut);

  console.log("Out-put before batch multiply: " + hostOut);

  mbdA = new JC.MatrixBatchD(2, 2, batchA);

  mbdB = new JC.MatrixBatchD(2, 2, batchB);

  mbdC = new JC.MatrixBatchD(2, 2, batchC);

  mbdA.multiplyMatrixBatch(mbdB, mbdC);

  matrixWatch.copyTo(4, hostOut);

  console.log("Out-put before batch multiply: " + hostOut);

  mbdA.destroy();

  mbdB.destroy();

  mbdC.destroy();

}).call(this);

//# sourceMappingURL=objectTest.js.map
