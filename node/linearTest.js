// Generated by CoffeeScript 1.10.0
(function() {
  var JC, assert, dumpMatrix;

  assert = require("assert");

  JC = require("./jc/build/Debug/jc.node");

  dumpMatrix = function(mat) {
    var c, j, k, oneRow, r, ref, ref1, results;
    results = [];
    for (r = j = 0, ref = mat.numRow; 0 <= ref ? j < ref : j > ref; r = 0 <= ref ? ++j : --j) {
      oneRow = "[";
      for (c = k = 0, ref1 = mat.numCol; 0 <= ref1 ? k < ref1 : k > ref1; c = 0 <= ref1 ? ++k : --k) {
        oneRow += mat.elements[c * mat.numRow + r] + " ";
      }
      oneRow += "]";
      results.push(console.log("" + oneRow));
    }
    return results;
  };

  describe("CUDA Base Utils Validation Check", function() {
    it("CUDA: cudaInitDevice", function(done) {
      assert.equal(typeof JC.cudaDeviceInit, 'function');
      return done();
    });
    return it("CUDA: cudaDeviceReset", function(done) {
      assert.equal(typeof JC.cudaDeviceReset, 'function');
      return done();
    });
  });

  describe("CUDA Functions Validation Test", function() {
    JC.cudaDeviceInit();
    it("CUDA: matrixMulMatrix(m1,m2,m3) Warmup...", function() {
      var end, mat1, mat2, mat3, num, start, v1, v2, v3;
      assert.equal(typeof JC.vectorAdd, 'function');
      v1 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 6; num = ++j) {
          results.push(num);
        }
        return results;
      })());
      v2 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 15; num = ++j) {
          results.push(num);
        }
        return results;
      })());
      v3 = new Float32Array(10);
      mat1 = {
        numRow: 2,
        numCol: 3,
        elements: v1
      };
      mat2 = {
        numRow: 3,
        numCol: 5,
        elements: v2
      };
      mat3 = {
        numRow: 2,
        numCol: 5,
        elements: v3
      };
      start = Date.now();
      JC.matrixMulMatrix(mat1, mat2, mat3);
      end = Date.now();
      console.log("Matrix2x3 #1}");
      console.log("Matrix3x5 #2}");
      console.log("Matrix2x5 #3}");
      console.log("\t elapse time:  " + (end - start) + " ms");
      return console.log("------------ * ------------------------- * -------------");
    });
    it("CUDA: matrixMulMatrix(m1,m2,m3) test #1", function() {
      var end, mat1, mat2, mat3, num, start, v1, v2, v3;
      assert.equal(typeof JC.vectorAdd, 'function');
      v1 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 6; num = ++j) {
          results.push(num);
        }
        return results;
      })());
      v2 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 15; num = ++j) {
          results.push(num);
        }
        return results;
      })());
      v3 = new Float32Array(10);
      mat1 = {
        numRow: 2,
        numCol: 3,
        elements: v1
      };
      mat2 = {
        numRow: 3,
        numCol: 5,
        elements: v2
      };
      mat3 = {
        numRow: 2,
        numCol: 5,
        elements: v3
      };
      start = Date.now();
      JC.matrixMulMatrix(mat1, mat2, mat3);
      end = Date.now();
      console.log("------------ * ------------------------- * -------------");
      console.log("Matrix2x3 #1:}");
      dumpMatrix(mat1);
      console.log("");
      console.log("Matrix3x5 #2:}");
      dumpMatrix(mat2);
      console.log("");
      console.log("Matrix2x5 #3:}");
      dumpMatrix(mat3);
      console.log("");
      console.log("\t elapse time:  " + (end - start) + " ms");
      return console.log("------------ * ------------------------- * -------------");
    });
    it("CUDA: matrixMulMatrix(m1,m2,m3) test #1", function() {
      var end, mat1, mat2, mat3, num, start, v1, v2, v3;
      assert.equal(typeof JC.vectorAdd, 'function');
      v1 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 10000; num = ++j) {
          results.push(Math.random());
        }
        return results;
      })());
      v2 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 10000; num = ++j) {
          results.push(Math.random());
        }
        return results;
      })());
      v3 = new Float32Array(10000);
      mat1 = {
        numRow: 100,
        numCol: 100,
        elements: v1
      };
      mat2 = {
        numRow: 100,
        numCol: 100,
        elements: v2
      };
      mat3 = {
        numRow: 100,
        numCol: 100,
        elements: v3
      };
      start = Date.now();
      JC.matrixMulMatrix(mat1, mat2, mat3);
      end = Date.now();
      console.log("------------ * ------------------------- * -------------");
      console.log("Matrix 100 x 100 #1}");
      console.log("Matrix 100 x 100 #2}");
      console.log("Matrix 100 x 100 #3}");
      console.log("\t elapse time:  " + (end - start) + " ms");
      return console.log("------------ * ------------------------- * -------------");
    });
    it("CUDA: vectorAdd(v1,v2,v3) Warmup...", function() {
      var end, num, start, v1, v2, v3;
      assert.equal(typeof JC.vectorAdd, 'function');
      v1 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 100; num = ++j) {
          results.push(Math.random());
        }
        return results;
      })());
      v2 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 100; num = ++j) {
          results.push(Math.random());
        }
        return results;
      })());
      v3 = new Float32Array(100);
      start = Date.now();
      JC.vectorAdd(v1, v2, v3);
      end = Date.now();
      console.log("------------ * ------------------------- * -------------");
      console.log("\t elapse time:  " + (end - start) + " ms");
      return console.log("------------ * ------------------------- * -------------");
    });
    it("CUDA: vectorAdd(v1,v2,v3) test #2", function() {
      var end, i, j, num, start, v1, v2, v3;
      assert.equal(typeof JC.vectorAdd, 'function');
      v1 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 10000000; num = ++j) {
          results.push(Math.random());
        }
        return results;
      })());
      v2 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 10000000; num = ++j) {
          results.push(Math.random());
        }
        return results;
      })());
      v3 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 10000000; num = ++j) {
          results.push(Math.random());
        }
        return results;
      })());
      start = Date.now();
      for (i = j = 0; j < 100; i = ++j) {
        JC.vectorAdd(v1, v2, v3);
      }
      end = Date.now();
      console.log("------------ * ------------------------- * -------------");
      console.log("\t Array #1:" + v1.slice(0, 3) + "... 1 billion elements");
      console.log("\t Array #2:" + v2.slice(0, 3) + "... 1 billion elements");
      console.log("\t Array Out:" + v3.slice(0, 3) + "... 1 billion elements");
      console.log("\t elapse time:  " + (end - start) + " ms");
      return console.log("------------ * ------------------------- * -------------");
    });
    it("CUDA: vectorAdd(v1,v2,v3) test #1", function() {
      var end, num, start, v1, v2, v3;
      assert.equal(typeof JC.vectorAdd, 'function');
      v1 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 1000000; num = ++j) {
          results.push(Math.random());
        }
        return results;
      })());
      v2 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 1000000; num = ++j) {
          results.push(Math.random());
        }
        return results;
      })());
      v3 = new Float32Array(1e6);
      console.log("------------ * ------------------------- * -------------");
      start = Date.now();
      JC.vectorAdd(v1, v2, v3);
      end = Date.now();
      console.log("\t Array #1:" + v1.slice(0, 3) + "... 1 million elements");
      console.log("\t Array #2:" + v2.slice(0, 3) + "... 1 million elements");
      console.log("\t Array Out:" + v3.slice(0, 3) + "... 1 million elements");
      console.log("\t elapse time:  " + (end - start) + " ms");
      return console.log("------------ * ------------------------- * -------------");
    });
    it("CUDA: vectorAdd(v1,v2,v3) test #2", function() {
      var end, num, start, v1, v2, v3;
      assert.equal(typeof JC.vectorAdd, 'function');
      v1 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 100; num = ++j) {
          results.push(Math.random());
        }
        return results;
      })());
      v2 = new Float32Array((function() {
        var j, results;
        results = [];
        for (num = j = 0; j < 100; num = ++j) {
          results.push(Math.random());
        }
        return results;
      })());
      v3 = new Float32Array(100);
      start = Date.now();
      JC.vectorAdd(v1, v2, v3);
      end = Date.now();
      console.log("------------ * ------------------------- * -------------");
      console.log("\t Array #1:" + v1.slice(0, 3) + "... 10 elements");
      console.log("\t Array #2:" + v2.slice(0, 3) + "... 10 elements");
      console.log("\t Array Out:" + v3.slice(0, 3) + "... 10 elements");
      console.log("\t elapse time:  " + (end - start) + " ms");
      return console.log("------------ * ------------------------- * -------------");
    });
    return JC.cudaDeviceReset();
  });

  describe("Linear Library Completeness", function() {
    var lb;
    lb = require("./linear");
    return it("N dimensions Vector inner product", function(done) {
      var Vector, v1, v2;
      Vector = lb != null ? lb.Vector : void 0;
      v1 = new Vector(5, [1, 2, 3, 4, 5]);
      v2 = new Vector(5, [1, 2, 3, 4, 5]);
      assert.equal(v1.innerProduct(v2), 55);
      return done();
    });
  });

}).call(this);

//# sourceMappingURL=linearTest.js.map
